<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis丨Plus Service CRUD]]></title>
    <url>%2F2019%2F04%2F16%2FMybatis%E4%B8%A8Plus%20Service%20CRUD%2F</url>
    <content type="text"><![CDATA[Mybatis-Plus Service CRUD Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290@RestController@RequestMapping("/user")public class UserController &#123; @Autowired private IUserService userService; private ISqlSegment iSqlSegment; /** * 新增一条 * * @return */ @PostMapping("/save") public boolean save() &#123; return userService.save(new User(null, "admin1", "admin1")); &#125; /** * 新增批量 * * @return */ @PostMapping("/save1") public boolean save1() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; userList.add(new User(null, "guest" + i, "guest" + i)); &#125; return userService.saveBatch(userList); &#125; /** * 分批次，新增批量 * * @return */ @PostMapping("/save2") public boolean save2() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); for (int i = 10; i &lt; 20; i++) &#123; userList.add(new User(null, "guest" + i, "guest" + i)); &#125; return userService.saveBatch(userList, 5); &#125; /** * 批量修改，插入 * * @return */ @PostMapping("/saveorupdate") public boolean saveorupdate() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); for (int i = 40; i &lt; 45; i++) &#123; userList.add(new User(i, "ITguest" + i, "ITguest" + i)); &#125; return userService.saveOrUpdateBatch(userList); &#125; /** * 根据id删除 * * @return */ @PostMapping("/removeById") public boolean removeById() &#123; return userService.removeById(3); &#125; /** * 根据Map删除 key为数据库的字段名 * * @return */ @PostMapping("/removeByMap") public boolean removeByMap() &#123; Map&lt;String, Object&gt; colMap = new HashMap&lt;&gt;(16); // 数据库字段 colMap.put("user_name", "iguest15"); return userService.removeByMap(colMap); &#125; /** * 根据 entity 条件，删除记录 * * @return */ @PostMapping("/remove") public boolean remove() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda().eq(User::getUserId, 24); return userService.remove(queryWrapper); &#125; /** * 删除（根据ID 批量删除） * * @return */ @PostMapping("/removeByIds") public boolean removeByIds() &#123; List&lt;Integer&gt; idList = new ArrayList&lt;&gt;(); idList.add(43); idList.add(44); return userService.removeByIds(idList); &#125; /** * 根据 ID 选择修改 * * @return */ @PostMapping("/updateById") public boolean updateById() &#123; User user = new User(); user.setUserId(40); return userService.updateById(user); &#125; /** * 根据 ID 选择修改 * * @return */ @PostMapping("/update") public boolean update() &#123; User user = new User(4, "test02", "test02"); UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.lambda().eq(User::getUserId, 4); return userService.update(user, updateWrapper); &#125; /** * 根据ID 批量更新 * * @return */ @PostMapping("/updateBatchById") public boolean updateBatchById() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(4, "test100", "test100")); userList.add(new User(5, "test101", "test101")); return userService.updateBatchById(userList, 1); &#125; /** * 根据 ID 查询 * * @return */ @GetMapping("/getById") public User getById() &#123; return userService.getById(1); &#125; /** * 查询（根据ID 批量查询） * * @return */ @GetMapping("/listByIds") public List&lt;User&gt; listByIds() &#123; List&lt;Integer&gt; idList = new ArrayList&lt;&gt;(); idList.add(1); idList.add(4); idList.add(5); return (List&lt;User&gt;) userService.listByIds(idList); &#125; /** * 查询（根据 columnMap 条件） * * @return */ @GetMapping("/listByMap") public List&lt;User&gt; listByMap() &#123; Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(16); columnMap.put("user_name", "test100"); return (List&lt;User&gt;) userService.listByMap(columnMap); &#125; /** * 根据 Wrapper，查询一条记录 * * @return */ @GetMapping("/getOne") public User getOne() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda().eq(User::getUserId, 5); return userService.getOne(queryWrapper, false); &#125; /** * 根据 Wrapper，查询一条记录 * * @return */ @GetMapping("/getMap") public Map&lt;String, Object&gt; getMap() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda().eq(User::getUserId, 1); return userService.getMap(queryWrapper); &#125; /** * 根据 Wrapper，查询一条记录 * * @return */ @GetMapping("/getObj") public Object getObj() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda().eq(User::getUserId, 1); return userService.getMap(queryWrapper); &#125; /** * 根据 Wrapper 条件，查询总记录数 * * @return */ @GetMapping("/count") public int count() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); return userService.count(queryWrapper); &#125; /** * 查询列表 * * @return */ @GetMapping("/list") public List&lt;User&gt; list() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda().eq(User::getUserId, 1); return userService.list(queryWrapper); &#125; /** * 查询列表 * * @return */ @GetMapping(value = "/list1") public List&lt;User&gt; list1() &#123; List&lt;User&gt; list = userService.list(); return list; &#125; /** * 翻页查询 * * @return */ @GetMapping("/list2") public IPage&lt;User&gt; list2() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();// queryWrapper.lambda().eq(User::getUserName, "admin"); IPage&lt;User&gt; page = userService.page(new Page&lt;&gt;(1, 5), queryWrapper); return page; &#125; /** * 查询列表 * * @return */ @GetMapping(value = "/listMaps") public List&lt;Map&lt;String, Object&gt;&gt; listMaps() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); return userService.listMaps(queryWrapper); &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS丨从零布局]]></title>
    <url>%2F2019%2F04%2F08%2FCSS%E4%B8%A8%E4%BB%8E%E9%9B%B6%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[浏览器内核浏览器内核分为两个部分：渲染引擎和JS引擎。 渲染引擎：它负责取得网页的内容（HTML、XML、图像等等）、整理样式（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 JS引擎：是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。 常见的浏览器内核可以分这四种：Trident(IE)、Gecko(FF)、Blink(chrome)、Webkit(Safari)。 注：Blink是webkit的一个分支。 Web标准构成 结构（html） 表现（css） 行为（js） HTML 块级 h1~h6 p div ul ol li 12341、新行开始2、高度、行高、内外边距，可控3、宽度默认是容器的100%4、可以容纳行内元素和其他块元素 行内 a span strong b em i del s ins u 12341、和相邻行内元素在一行上2、宽高无效。水平方向的padding和margin可以设置，垂直方向无效。3、默认宽度就是自身内容的宽度。4、只能容纳文本或其他行内行内元素。（a特殊） 行内块元素 img input td 1231、和相邻行内元素在一行上，但之间会有空白缝隙2、默认宽度就是本身内容的宽度3、高度、行高、内外边距可以控制 CSS选择器 类 id 通配符 *{ margin:0; padding:0; } 交集 h5.class { color: red; } 并集 .class, h3 { color: red; } 后代 .class h3 { color: red; } 子元素 .class&gt;h3 { color: red; } 伪类 :link :visited :hover :active 显示模式转换 块转行内：display:inline 行内转块：display:block 块、行内转行内块: diaplay:inline-block 盒子模型CSS就是三个大模块：盒子模型、浮动、定位，其他都是细节。 每个盒子组成：元素的内容、内边距（padding）、边框（border）、外边距（margin）组成。 布局稳定性1width &gt; padding &gt; margin 原因： margin会有外边距合并，还有ie6下面margin加倍的bug padding会影响盒子大小，需要进行加减计算 width没毛病 浮动浮动:会脱离标准流的控制，不占位置，会影响标准流。浮动只有左右浮动。 浮动的盒子，漂浮在其他标准流盒子上面 浮动的盒子，不占位置，它原来的位置漏给了标准的盒子 浮动的盒子，需要和标准流的父级搭配使用。找最新的父级元素对齐，但不会超出内边距的范围。 浮动的盒子，可以使元素显示模式体现为行内块特性 版心和布局版心一般在浏览器水平居中显示，常见宽度：960px/980px/1000px/1200px… 清除浮动本质清除浮动主要是为了解决父级元素，因为子级浮动引起内部高度为0的问题。 clear 123clear: left; // 清除左侧浮动clear: right; // 清除右侧浮动clear: both; // 同时清除左右两侧浮动的影响 overflow 12给父级添加overflow: hidden / auto / scroll ， 都可以实现 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 after:after方法为空元素的升级版，好处是不用单独加标签了1234567891011.clearfix:after &#123; content: '.'; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; *zoom: 1; // IE6,7专用&#125; 优点：符合闭合浮动的思想，结构语义化正确。缺点：ie6，7不支持:after，使用zoom:1触发hasLayout。注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 before和after12345678910.clearfix:before,.clearfix:after &#123; content: ""; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 定位 position （子绝父相） static 自动 relative 相对，相对于文档流的位置进行定位 absolute 绝对，相对于其上一个已经定位的父元素进行定位 fixed 固定，相对于浏览器窗口进行定位121、固定定位的元素跟父亲没有任何关系，只认浏览器2、固定定位完全脱离标准流，不占有位置，不随着滚动条滚动。 叠放次序 z-index当对多个元素同时设置定位时，定位元素之间有可能会发生重叠12341、z-index的默认是0，值越大，越在上面。2、如果值相同，按书写顺序。3、数字没有单位4、只有相对定位、绝对定位、固定定位才有这个属性，其他标准流，浮动，静态定位没有这个属性。 定位模式转换元素添加了绝对定位和固定定位之后，元素模式也会发生转换，都转换为行内块模式。因此，行内元素，添加了绝对定位或者固定定位后浮动后，可以不用转换模式，直接给宽高就好了。 元素的显示和隐藏 display 显示 12display: none; // 隐藏元素（不在保留位置）display: block; // 显示元素 visibility 可见 12visible: 可见hidden: 隐藏 // 保留原位置 overflow 溢出当对象的内容超过其指定高度及宽度时管理内容。 1234visibel: 不剪切内容也不添加滚动条。auto: 超出自动显示滚动条，不超出不显示滚动条。hidden：不显示超过对象尺寸的内容，超出的部分隐藏掉scroll: 不管超出内容，总是显示滚动条。 记录(橙M青P)清除内外边距1234* &#123; margin:0; /* 清除外边距 */ padding:0; /* 清除内边距 */&#125; 外边距合并相邻块元素垂直外边距的合并:当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。1解决方案：避免就好！ 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。123解决方案：1、可以为父元素定义1px的上边框或上内边距；2、可以为父元素添加 overflow:hidden; 计算盒子大小1231、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效。（img和input除外）2、计算盒子模型的高度时，还应该考虑上下两个盒子垂直外边距合并的情况。3、如果一个盒子没有给定高度、宽度、或集成父亲的高度、宽度，则padding不会影响本盒子的大小。 绝对定位的盒子，水平和垂直居中121、首先left50%父盒子的一半大小2、走自己外边距负的一半值就可以margin-left]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git丨空文件夹提交]]></title>
    <url>%2F2019%2F04%2F04%2FGit%E4%B8%A8%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[空文件夹提交解决：1find . -type d -empty -exec touch &#123;&#125;/.gitignore \;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第二季 第1集 聊聊事件]]></title>
    <url>%2F2019%2F04%2F02%2FReact%E4%B8%A8%E7%AC%AC%E4%BA%8C%E5%AD%A3%20%E7%AC%AC1%E9%9B%86%20%E8%81%8A%E8%81%8A%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件系统Virtual DOM 在内存中是以对象的形式存在的，如果想要在这些对象上添加事件，就会非常简单。React 基于 Virtual DOM 实现了一个 SyntheticEvent （合成事件）层，我们所定义的事件处理器会接收到一个 SyntheticEvent 对象的实例。并且与原生的浏览器事件一样拥有同样的接口，同样支持事件的冒泡机制，我们可以使用 stopPropagation() 和 preventDefault() 来中断它。所有事件都自动绑定到最外层上。如果需要访问原生事件对象，可以使用 nativeEvent 属性。 合成事件的实现机制在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定。 事件委派React事件的代理机制：它并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。 自动绑定在使用 ES6 classes 或者纯函数时，我们需要手动实现 this 的绑定。 常用的几种绑定方法： 方法1：bind方法.这个方法可以帮助我们绑定事件处理器内的 this ，并可以向事件处理器中传递参数.123456class App extends Component &#123; handleClick(e, arg) &#123; &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick(this, 'text')&#125;&gt;button&lt;/button&gt; &#125;&#125; 方法2：构造器内声明在组件的构造器内完成了 this 的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听器时去执行绑定操作.12345678910class App extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this) &#125; handleClick(e) &#123; &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;button&lt;/button&gt; &#125;&#125; 方法3：箭头函数箭头函数不仅是函数的语法糖，它还自动绑定了定义此函数作用域的this，因此我们不需要再对它使用bind方法。12345678class App extends Component &#123; const handleClick = (e) =&gt; &#123; log(e) &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;button&lt;/button&gt; &#125;&#125; 或12345678class App extends Component &#123; handleClick(e)&#123; log(e) &#125; render() &#123; return &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;button&lt;/button&gt; &#125;&#125; 在React中使用原生事件在componentDidMount会在组件已经完成安装并且在浏览器中存在真实的DOM后电泳，此时可以完成原生事件的绑定。123456789101112class App extends Component &#123; componentDidMount() &#123; this.refs.button.addEventListener('click', e =&gt; &#123;this.handleClick(e)&#125;) &#125; handleClick(e) &#123; console.log(e) &#125; componentWillUnmount() &#123; this.refs.button.removeEventListener('click') &#125; render() &#123; return &lt;button ref="button"&gt;TEST&lt;/button&gt; &#125;&#125; 注：在React中使用DOM原生事件时，一定要在组件卸载时手动移除，否则很可能出现内存泄漏的问题。 而使用合成事件系统时则不需要，React内部已经帮你处理了。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第一季 第6集 React与DOM]]></title>
    <url>%2F2019%2F03%2F29%2FReact%E4%B8%A8%E7%AC%AC%E4%B8%80%E5%AD%A3%20%E7%AC%AC6%E9%9B%86%20React%E4%B8%8EDOM%2F</url>
    <content type="text"><![CDATA[React与DOM从React0.14版本开始，React将React中涉及DOM操作的部分剥离开，目的是为了抽象React，同时适用于Web端和移动端。ReactDOM的关注点在DOM上，因此适用于WEB端。 在React组件的开发实现中，并不会用到ReactDOM，只有在顶层组件以及由于React模型所限而不得不操作DOM的时候，才会使用它。 ReactDOMAPI非常少，只有findDOMNode, unmountComponentAtNode和render。 findDOMNode在组件生命周期，DOM真正被添加到HTML中的生命周期方法是componentDidMount和componentDidUpdate方法。在这两个方法中，我们看可以获取真正的DOM元素。React提供获取DOM元素的方法有两种，其一是ReactDOM提供的findDOMNode。1234567class App extends Component &#123; componentDidMount() &#123; // this 为当前组件的实例 const dom = ReactDOM.findDOMNode(this) &#125; render() &#123; &#125;&#125; 如果在render中返回null，那么findDOMNode也返回null。findDOMNode只对已经挂载的组件有效。 render把React渲染的虚拟DOM渲染到浏览器的DOM当中，就要使用render方法。12345ReactComponent render( ReactElement element, DOMElement container, [function callback]) 该方法把元素挂载到container中，并返回element的实例（即refs引用）。当然，如果是无状态组件，render会返回null。当组件装载完毕时，callback就会被调用。 当组件在初次渲染之后，再次更新时，React不会把整个组件重新渲染一次，而会用它高效的DOM diff算法做布局的更新。这是React最大的亮点之一。 refs12const myAppInstance = ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))myAppInstance.doSth() 利用render方法得到了App组件的实例，然后就可以对它做一些操作。但在组件内，jsx是不会返回一个组件的实例的。它只是一个ReactElement，只是告诉React被挂载的组件应该长什么样的1const myApp = &lt;App /&gt; refs就是为此而生，它是React组件 中非常特殊的props，可以附加到任何一个组件上。组件被调用时会新建一个该组件的实例，而refs就会指向这个实例。 1234567891011componentDidMount() &#123; const myComp = this.refs.myComp; const dom = findDOMNode(myComp); &#125; render() &#123; return ( &lt;div&gt; &lt;Comp ref="myComp" /&gt; &lt;/div&gt; ); &#125; 对于React组件来说，refs会指向一个组件类的实例，所以可以调用该类定义的任何方法。如果需要访问该组件的真是DOM，可以用ReactDOM。findDOMNode来找到DOM节点，但并不推荐这样做。因为这在大部分情况下都打破了封装性，而且通常能用更新清晰的办法在React中构建代码。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第一季 第5集 React生命周期]]></title>
    <url>%2F2019%2F03%2F26%2FReact%E4%B8%A8%E7%AC%AC%E4%B8%80%E5%AD%A3%20%E7%AC%AC5%E9%9B%86%20React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React生命周期React life cycle 分为两类： 当组件在挂载或卸载时； 当组件接收新的数据时，即组件更新时。 挂载过程组件挂载：主要做组件状态的初始化。 12345678910111213class App extends Component &#123; static propTypes = &#123; &#125; // props类型检查 static defaultProps = &#123; &#125; // props默认类型 constructor(props) &#123; super(props) this.state = &#123; &#125; // 初始化state &#125; componentWillMount() &#123;&#125; // render之前 componentDidMound() &#123;&#125; // render之后 render() &#123; return &lt;div&gt;this is a demo&lt;/div&gt; &#125;&#125; 这propTypes和defaultProps两个属性被声明为static属性，表示外面也可以访问它们，如：App.propTypes和App.defaultProps; 如果在componentDidMound执行setState方法，那么在初始化的时候，就渲染了两次。这并不好。但在实际的场景中，如计算组件的位置或宽高时，不得不让组件先寻人，更新必要的信息后，再次渲染。 卸载过程123456class App extends Component &#123; componentWillUnmount() &#123;&#125; // 执行清理方法。如：回收或清楚定时器等 render() &#123; return &lt;div&gt;this is a demo.&lt;/div&gt; &#125;&#125; 数据更新过程更新是指：父组件向下传递props或组件自身执行setState方法时，发生的更新动作。 执行setState，那么会依次执行1234shouldComponentUpdate(nextProps, nextState) &#123; return true &#125; // false：组件不再向下执行生命周期方法componentWillUpdate(nextProps, nextState) &#123; &#125; // 更新渲染前render() &#123; return &lt;div&gt;dmeo&lt;/div&gt; &#125;componentDidUpdate(preProps, preState) &#123; &#125; // 更新渲染后 组件是由父组件更新props而更新的，那在shouldComponentUpdate之前会先执行componentWillReceiveProps方法。这个方法可以作为React在props传后后，渲染之前setState的机会。在这个方法调用setState是不会二次渲染的。 React生命周期流程图 ES6 Classes 和 createClass构建组件方法的异同 在初始化方法有所不同，但生命周期函数没有变化。在ES6 Class中的静态法用静态关键词static声明。 推荐更倾向于ES6 Class方式来构建组件。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第一季 第4集 React数据流]]></title>
    <url>%2F2019%2F03%2F20%2FReact%E4%B8%A8%E7%AC%AC%E4%B8%80%E5%AD%A3%20%E7%AC%AC4%E9%9B%86%20React%E6%95%B0%E6%8D%AE%E6%B5%81%2F</url>
    <content type="text"><![CDATA[React数据流在React中，数据是从上向下单向流动的，即从父组件到子组件。这个原则让组件之间的关系变得简单且可预测。 state和props是React组件中最重要的概念。 如果顶层组件初始化props，那么React会向下遍历整棵组件数，重新尝试渲染所有相关的子组件。 state只关心每隔组件自己的内部的状态，这些状态只能在组件内部改变。 把组件看成一个函数，那么它接收了props作为参数，内部由state作为函数的内部参数，返回一个虚拟DOM的实现。 state管理组件的内部状态，React中，把这类状态称为state。 当组件内部使用库内置的setState方法时，最大的表现行为就是该组件会重新渲染。 1234567891011121314handleClick(e) &#123; e.preventDefault() this.setState(&#123; count: this.state.count + 1 &#125;)&#125;render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;a href="#" onClick=&#123;this.handleClick&#125;&gt;更新&lt;/a&gt; &lt;/div&gt; )&#125; 注意：setState是一个异步的方法，一个生命周期内所有的setState方法会合并操作。 state很棒，但项目的深入，并不推荐滥用state，过多的内部状态会让数据流混乱，程序难易维护。 React组件设计，分别有如下两种组件： 智能组件 木偶组件 propsprops是properties的缩写。 props是React用来让组件之间互相联系的一种机制 ，就像方法的参数一样。 React的单向数据流，主要的流动管道就是props。 props本身是不可变的。当改变props的原始值时，React会报错，组件的props一定来于默认属性或通过父组件传递而来。 如果要渲染一个对props加工后的值，最简单的方法就是使用局部变量或直接在jsx中计算结果。 子组件prop在React中有一个重要且内置的prop – children，它代表组件的子组件集合。 1234567render() &#123; return ( &lt;div&gt; &#123;React.Children.map(this.props.children, (child) =&gt; &#123;...&#125;)&#125; &lt;/div&gt; )&#125; 这种调用方式称为子组件。它指的是组件内的子组件是通过动态计算得到的。 组件porps用function prop 与父组件通信对于state来说，它的通信集中在组件内部；对于props来说，它的通信是父组件向子组件的传播。 123handleClick(index) &#123; this.props.onClick(&#123;index&#125;)&#125; 通过点击事件handleClick触发了onClick prop回调函数给父组件必要的值。 propTypesJS不是强类型语言。正是一个开发时约束的问题。React推处了propTypes。 propTypes用于规范props的类型与必需的状态。如果组件定义propTypes，那么在开发环境下，就会组件的props值的类型作检查，如果不匹配，React实时在控制台报警告。在生产环境下，这是不会进行检查的。 123456static propTypes = &#123; classPrefix: React.PropTypes.string, activeIndex: React.PropTypes.number, onChange: React.PropTypes.func, isLogin: React.PropTypes.bool&#125; propTypes有很多类型支持，不仅有基础类型，还包括枚举和自定义类型。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第一季 第3集 React组件]]></title>
    <url>%2F2019%2F03%2F20%2FReact%E4%B8%A8%E7%AC%AC%E4%B8%80%E5%AD%A3%20%E7%AC%AC3%E9%9B%86%20React%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[React组件React组件基本由3个部分组成：属性(props)、状态(state)、生命周期。 官方在React组件构建上提供了三种不同的方法： React.createClass ES6 Classes 无状态函数(stateless function) React.createClass这种方式是构建组件是React最传统、也是兼容最好的方法。在0.14版本发布之前，这一直都是React官方唯一指定的组件写法。12345678910111213141516const Button = React.createClass(&#123; getDefaultProps() &#123; return &#123; color: 'blue', text: 'Confirm' &#125; &#125;, render()&#123; const &#123;color, text&#125; = this.props return ( &lt;button className=`&#123;btn btn-$&#123;color&#125;&#125;`&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; ) &#125;&#125;) ES6 Classes123456789101112131415161718import React, &#123;Component&#125; from 'React'class Button extends Component &#123; constructor(props) &#123; super(props) &#125; static defaultProps = &#123; color: 'blue', text: 'Confirm' &#125; render()&#123; const &#123;color, text&#125; = this.props return ( &lt;button className=`&#123;btn btn-$&#123;color&#125;&#125;`&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; ) &#125;&#125; 在React应用中，极少让子类去继承功能组件。试想在UI层面小的修改就会影响到整体交互或样式，牵一发而动全身，用继承来抽象往往是事倍功半。在React组件开发中，常用的方式将组件拆分到合理的粒度，用组合的方式合成业务组件。 无状态函数在0.14版本之后新增的，且官方推崇。1234567function Button(&#123;color='blue', text='Confirm'&#125;) &#123; return ( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; )&#125; 无状态组件，只传入props和context两个参数；它不存在state，也没有生命周期方法，render方法。不过像propTypes和defaultProps还是可以通过向方法设置静态属性来实现的。 在合适的情况下，都应该且必须使用无状态组件。无状态组件不像上述两种方法在调用的时会创建新实例，它创建时始终保持了一个实例，避免了不必要的检查和内存分配，做到了内部优化。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第一季 第2集 JSX]]></title>
    <url>%2F2019%2F03%2F20%2FReact%E4%B8%A8%E7%AC%AC%E4%B8%80%E5%AD%A3%20%E7%AC%AC2%E9%9B%86%20JSX%2F</url>
    <content type="text"><![CDATA[JSX语法JSX的由来React与其他JS模板语言不同之处，在于React是通过创建与更新虚拟元素来管理整个虚拟DOM。 虚拟元素：可以理解为真实元素的对应，它的构建与更新都是在内存中完成的，并不会真正渲染到DOM中去。 在React中创建的虚拟元素，可以分为两类：DOM元素（DOM element）和组件元素（component element），对应着原生的DOM元素和自定义元素。而JSX与创建元素的过程有莫大的关联。 DOM元素WEB页面从HTML转JSON对象。示例： HTML 123&lt;button class="btn btn-blue"&gt; &lt;em&gt;hello jsx&lt;/em&gt;&lt;/button&gt; JSON 123456789101112&#123; type: 'button', props: &#123; className: 'btn btn-blue', children: [&#123; type: 'em', props: &#123; children: 'hello jsx' &#125; &#125;] &#125;&#125; 这样就可以在JS中创建虚拟DOM了。 组件元素 封装button元素，构建按钮的公共方法：1234567891011121314const Button = (&#123;color, text&#125;) =&gt; &#123; return &#123; type: 'button', props: &#123; className: `btn btn-$&#123;color&#125;`, children: &#123; type: 'em', props: &#123; children: `$&#123;text&#125;` &#125; &#125; &#125; &#125;&#125; 当要生成DOM元素中具体的按钮时，就可以使用下面方式来创建：1Button(&#123;color: 'blue', text: 'hello jsx'&#125;) 上述构建Button的公共方法，也是作为元素而存在，方法名对应了DOM的元素类型，参数对应DOM元素的属性，这样它就具备了元素的两大必要条件，这样的有元素，就是自定义类型元素，或组件元素。用JSON描述它：1234567&#123; type: Button, props: &#123; color: 'blue', childre: 'hello jsx' &#125;&#125; 这也是React的核心思想之一。我们可以让元素彼此嵌套或混合。这些层层封装的组件元素，就是所有的React组件，最终我们可以用递归的方式构建出完全的DOM元素树。 如果是大量的表达式，就很难维护了。jsx语法就应运而生了。jsx是将html语法直接加入到js代码中，在通过翻译器转换到纯js后，有浏览器执行。在实际开发中，jsx在产品打包阶段都已经编译成纯js，不会带来任何副作用，反而回让代码更加直观并已于维护。 现在已全部采用Babel的jsx编译器实现。Babel作为专门为JS语法编译工具，达到了“一处配置，统一运行”的目的。 jsx 1234567cosnt DeleteAccount = () =&gt; &#123; &lt;div&gt; &lt;p&gt;Are you sure ?&lt;/p&gt; &lt;DangerButton&gt;Confirm&lt;/DangerButton&gt; &lt;Button color="bule"&gt;Cancel&lt;/Button&gt; &lt;/div&gt;&#125; 用Babel转移成React可以执行的代码 123456789101112131415161718192021var DeleteAccount = function DeleteAccout() &#123; return React.createElement( 'div', null, ReactElement( 'p', null, 'Are you sure ?' ), React.createElement( DangerButton, null, 'Confirm' ), React.createElement( Button, &#123;color: 'blue'&#125;, 'Cancel' ) )&#125; 上述，除了在创建元素使用了React.createElement创建之外，其他的和JSON的结构一样的。 jsx基本语法 xml基本语法 12定义标签时，只允许被一个标签包裹。标签一定要闭合。 元素类型 123456789-- 元素类型DOM元素：小写组件元素：大写-- 注释&#123;/* 哈哈哈 */&#125;-- DOCTYPEDOCTYPE头是一个非常特殊的标志，一般会在使用React作为服务端渲染时用到。在HTML中DOCTYPE是没有闭合,也就是说我们无法渲染它。 元素属性 12345678910111213141516171819class属性改为classNamefor属性改为htmlFor//-- 展开属性const component = &lt;Component name=&#123;name&#125; value=&#123;value&#125; /&gt;const data = &#123;name:'foo', value:'bar'&#125;const component = &lt;Component &#123;...data&#125; /&gt;// 反模式const component = &lt;Component /&gt;component.props.name = name;component.props.value = value;上面的写法，React不能帮你检查属性类型（propTypes），这样即使组件的属性类型有错误，不能得到清晰的错误提示//-- 自定义HTML属性组件的最终目的是输出虚拟DOM，也就是需要被渲染到界面的机构。其狠心渲染的方式，就是render方法。它是React组件生命周期的一部分，也是最核心的函数之一。 JS属性表达式 12345const person = &lt;Person name=&#123;window.isLoggedIn ? window.name: ''&#125; /&gt;const content = &lt;Container&gt; &#123;window.isLoggedIn ? &lt;Nav/&gt;: &lt;Login/&gt;&#125;&lt;/Container&gt; HTML转义 123React会将所有要显示的DOM的字符串转义，防止XSS。React提供了dangerousSetInnerHtml属性。它的作用是避免React转义字符，在确定必要的情况下可以使用它: &lt;div dangerouslySetInnerHtml=&#123;&#123;__html: 'cc &amp;copy; 2019'&#125;&#125; /&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨第一季 第1集 Hello React]]></title>
    <url>%2F2019%2F03%2F18%2FReact%E4%B8%A8%E7%AC%AC%E4%B8%80%E5%AD%A3%20%E7%AC%AC1%E9%9B%86%20Hello%20React%2F</url>
    <content type="text"><![CDATA[初识ReactReact是FB在2013年开源在Github上的JavaScript库。 专注视图层React并不是完整的MVC/MVVM框架，它专注于视图层解决方案。对于复杂的应用，根据场景可搭配Redux来使用。 Virtual DOM真实页面对应一个DOM树。 传统页面开发，更新页面，都是手动操作DOM来更新。 在WEB前端中，性能消耗最大的就是DOM操作，而且这部分代码会很难维护。 React是把真实的DOM树转成Js对象树，也就是Virtual DOM。 每次数据更新后，重新计算Virtual DOM，和上一次做对比，对发生变化的部分，做批量更新。React有shouldComponentUpdate声明周期回调，来减少数据变化后不必要的对比过程，以保证性能。 3、函数式编程React把过去不断重复构建UI的过程抽成组件，在给定参数的情况下，约定渲染对应的UI界面。 React充分利用很多函数式方法去减少冗余代码。 函数式编程才是React的精髓。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨create-react-app配置antd]]></title>
    <url>%2F2019%2F03%2F01%2FReact%E4%B8%A8create-react-app%E9%85%8D%E7%BD%AEantd%2F</url>
    <content type="text"><![CDATA[安装依赖1yarn add react-app-rewired customize-cra babel-plugin-import 配置package.json12345678"scripts": &#123;- "start": "react-scripts start",+ "start": "react-app-rewired start",- "build": "react-scripts build",+ "build": "react-app-rewired build",- "test": "react-scripts test",+ "test": "react-app-rewired test",&#125; 修改默认配置在项目根目录创建一个 config-overrides.js 用于修改默认配置。1234567891011const &#123; override, fixBabelImports &#125; = require("customize-cra"); module.exports = override( fixBabelImports("babel-plugin-import", &#123; libraryName: "antd", style: "css" &#125;) ); 测试1234567891011import &#123; Button &#125; from 'antd';ReactDOM.render( &lt;div&gt; &lt;Button type="primary"&gt;Primary&lt;/Button&gt; &lt;Button&gt;Default&lt;/Button&gt; &lt;Button type="dashed"&gt;Dashed&lt;/Button&gt; &lt;Button type="danger"&gt;Danger&lt;/Button&gt; &lt;/div&gt;, mountNode); 备注babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件。 参考1https://ant.design/docs/react/use-with-create-react-app-cn]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux丨CentOS6.8安装Nginx1.10]]></title>
    <url>%2F2019%2F03%2F01%2FLinux%E4%B8%A8CentOS6-8%E5%AE%89%E8%A3%85Nginx1.10%2F</url>
    <content type="text"><![CDATA[安装环境12- 系统环境：CentOS6.8 64bit- JDK版本：1.10.2 安装依赖1yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载nginx1wget http://nginx.org/download/nginx-1.10.2.tar.gz 解压1tar -zxvf nginx-1.10.2.tar.gz 执行配置文件12cd nginx-1.10.2./configure 安装1make &amp;&amp; make install 查询安装目录1whereis nginx 启动nginx12cd /usr/local/nginx/sbin./nginx 重启nginx1./nginx -s reload 停止nginx12345678910ps -ef | grep nginx-- 从容停止： kill -QUIT xxx-- 快速停止： kill -TERM xxx-- 强制停止：kill -9 nginx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx丨开启Gzip]]></title>
    <url>%2F2019%2F03%2F01%2FNginx%E4%B8%A8%E5%BC%80%E5%90%AFGzip%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; gzip_min_length 1k; #低于1kb的资源不压缩 gzip_comp_level 3; #压缩级别【1-9】，越大压缩率越高，同时消耗cpu资源也越多，建议设置在4左右。 gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css; #需要压缩哪些响应类型的资源，多个空格隔开。不建议压缩图片，下面会讲为什么。 gzip_disable "MSIE [1-6]\."; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持） gzip_vary on; #是否添加“Vary: Accept-Encoding”响应头 server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; try_files $uri $uri/ @router; index index.html; &#125; location @router&#123; rewrite ^.*$ /index.html last; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>React</tag>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React丨umi+dva+antd CRUD Demo]]></title>
    <url>%2F2019%2F02%2F23%2FReact%E4%B8%A8umi%2Bdva%2Bantd%20CRUD%20Demo%2F</url>
    <content type="text"><![CDATA[开始之前 node 8.4或以上版本 用cnpm或yarn管理包依赖 安装umi1yarn global add umi 创建umi项目1yarn create umi 选择app123456? Select the boilerplate type (Use arrow keys) ant-design-pro - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.❯ app - Create project with a simple boilerplate, support typescript. block - Create a umi block. library - Create a library with umi. plugin - Create a umi plugin. 是否选择TS?12? Do you want to use typescript? (y/N)N 希望启动什么功能?12345? What functionality do you want to enable? (*) antd&gt;(*) dva ( ) code splitting ( ) dll 根据上述选择，生成文件1234567891011121314151617181920212223 create package.json create .gitignore create .editorconfig create .env create .eslintrc create .prettierignore create .prettierrc create .umirc.js create mock\.gitkeep create src\app.js create src\assets\yay.jpg create src\global.css create src\layouts\__tests__\index.test.js create src\layouts\index.css create src\layouts\index.js create src\models\.gitkeep create src\pages\__tests__\index.test.js create src\pages\index.css create src\pages\index.js create tslint.yml create webpack.config.js✨ File Generate DoneDone in 276.11s. 安装依赖1yarn 启动本地开发环境1yarn start 如果顺利，在浏览器中输入localhost:8000，可以看到下面的页面。 配置代理 编辑.umirc.js12345678// 配置代理，能通过Restful方式访问&quot;proxy&quot;: &#123; &quot;/api&quot;: &#123; &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: &#123; &quot;^/api&quot;: &quot;&quot; &#125; &#125;&#125; mock api eg: http://localhost:8000/api/users 生成users路由umi 中文件即路由，所以我们要新增路由，新建文件即可! 新增src/pages/users/index.js文件，命令：1234$ umi g page users/index create src\pages\users\index.js create src\pages\users\index.css√ success src/pages/users/index.js文件内容，如下：12345678import styles from &apos;./index.css&apos;;export default function () &#123; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;h1&gt;Page users index&lt;/h1&gt; &lt;/div&gt; );&#125; 在浏览器中输入http://localhost:8000/users, 会看到Page users index的输出。 构造users models和 service新增 src/pages/users/models/users.js，内容如下： 1234567891011121314151617181920212223242526272829import * as usersService from &apos;../services/users&apos;;export default &#123; namespace: &apos;users&apos;, state: &#123; list: [], total: null, &#125;, reducers: &#123; save(state, &#123; payload: &#123; data: list, total &#125; &#125;) &#123; return &#123; ...state, list, total &#125;; &#125;, &#125;, effects: &#123; *fetch(&#123; payload: &#123; page &#125; &#125;, &#123; call, put &#125;) &#123; const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;); yield put(&#123; type: &apos;save&apos;, payload: &#123; data, total: headers[&apos;x-total-count&apos;] &#125; &#125;); &#125;, &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === &apos;/users&apos;) &#123; dispatch(&#123; type: &apos;fetch&apos;, payload: query &#125;); &#125; &#125;); &#125;, &#125;,&#125;; 新增 src/pages/users/services/users.js： 12345import request from &apos;../../../utils/request&apos;;export function fetch(&#123; page = 1 &#125;) &#123; return request(`/api/users?_page=$&#123;page&#125;&amp;_limit=5`);&#125; 由于我们需要从 response headers 中获取 total users 数量，所以需要改造下 src/utils/request.js： 12345678910111213141516171819202122232425262728293031import fetch from &apos;dva/fetch&apos;;function checkStatus(response) &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response; &#125; const error = new Error(response.statusText); error.response = response; throw error;&#125;/** * Requests a URL, returning a promise. * * @param &#123;string&#125; url The URL we want to request * @param &#123;object&#125; [options] The options we want to pass to &quot;fetch&quot; * @return &#123;object&#125; An object containing either &quot;data&quot; or &quot;err&quot; */export default async function request(url, options) &#123; const response = await fetch(url, options); checkStatus(response); const data = await response.json(); const ret = &#123; data, headers: &#123;&#125;, &#125;; if (response.headers.get(&apos;x-total-count&apos;)) &#123; ret.headers[&apos;x-total-count&apos;] = response.headers.get(&apos;x-total-count&apos;); &#125; return ret;&#125; 再次访问http://localhost:8000/users页面的时候，观察一下Network, 应该是有Request URL: http://localhost:8000/api/users?_page=1&amp;_limit=5, 也有对应的Response返回值。说明API接口已经调通了，接来下就开始弄视图层了。 添加页面，展示users列表我们把组件存在 src/pages/users/components 里，所以在这里新建 Users.js 和 Users.css。具体参考这个 Commit。 需留意两件事： 对 model 进行了微调，加入了 page 表示当前页 由于 components 和 services 中都用到了 pageSize，所以提取到 src/constants.js 改完后，切换到浏览器，应该能看到带分页的用户列表。 添加 layout添加 layout 布局，使得我们可以在首页和用户列表页之间来回切换。umi 里约定 layouts/index.js 为全局路由，所以我们新增 src/layouts/index.js 和 CSS 文件即可。 参考这个 Commit。 注意： 页头的菜单会随着页面切换变化，高亮显示当前页所在的菜单项 处理 loading 状态dva 有一个管理 effects 执行的 hook，并基于此封装了 dva-loading 插件。通过这个插件，我们可以不必一遍遍地写 showLoading 和 hideLoading，当发起请求时，插件会自动设置数据里的 loading 状态为 true 或 false 。然后我们在渲染 components 时绑定并根据这个数据进行渲染。 umi-plugin-dva 默认内置了 dva-loading 插件。 然后在 src/components/Users/Users.js 里绑定 loading 数据： 1+ loading: state.loading.models.users, 具体参考这个 Commit 。 刷新浏览器，你的用户列表有 loading 了没? 处理分页只改一个文件 src/pages/users/components/Users.js 就好。 处理分页有两个思路： 发 action，请求新的分页数据，保存到 model，然后自动更新页面 切换路由 (由于之前监听了路由变化，所以后续的事情会自动处理) 我们用的是思路 2 的方式，好处是用户可以直接访问到 page 2 或其他页面。 参考这个 Commit 。 删除功能 service, 修改 src/pages/users/services/users.js： 12345export function remove(id) &#123; return request(`/api/users/$&#123;id&#125;`, &#123; method: 'DELETE', &#125;);&#125; model, 修改 src/pages/users/models/users.js： 12345*remove(&#123; payload: id &#125;, &#123; call, put, select &#125;) &#123; yield call(usersService.remove, id); const page = yield select(state =&gt; state.users.page); yield put(&#123; type: 'fetch', payload: &#123; page &#125; &#125;);&#125;, component, 修改 src/pages/users/components/Users.js，替换 deleteHandler 内容： 1234dispatch(&#123; type: 'users/remove', payload: id,&#125;); 切换到浏览器，删除功能应该已经生效。 编辑功能处理用户编辑和前面的一样，遵循三步走： service model component 先是 service，修改 src/pages/users/services/users.js： 123456export function patch(id, values) &#123; return request(`/api/users/$&#123;id&#125;`, &#123; method: 'PATCH', body: JSON.stringify(values), &#125;);&#125; 再是 model，修改 src/pages/users/models/users.js： 12345*patch(&#123; payload: &#123; id, values &#125; &#125;, &#123; call, put, select &#125;) &#123; yield call(usersService.patch, id, values); const page = yield select(state =&gt; state.users.page); yield put(&#123; type: 'fetch', payload: &#123; page &#125; &#125;);&#125;, 最后是 component，详见 Commit。 需要注意的一点是，我们在这里如何处理 Modal 的 visible 状态，有几种选择： 存 dva 的 model state 里 存 component state 里 另外，怎么存也是个问题，可以： 只有一个 visible，然后根据用户点选的 user 填不同的表单数据 几个 user 几个 visible 此教程选的方案是 2-2，即存 component state，并且 visible 按 user 存。另外为了使用的简便，封装了一个 UserModal 的组件。 完成后，切换到浏览器，应该就能对用户进行编辑了。 用户创建相比用户编辑，用户创建更简单些，因为可以共用 UserModal 组件。和编辑比较类似，详见 Commit 。 Githubhttps://github.com/wangjianuo/umi-dva-crud-demo 参考资料123https://umijs.org/zh/https://github.com/dvajs/dvahttps://github.com/sorrycc/blog/issues/62]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Antd</tag>
        <tag>Umi</tag>
        <tag>Dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux丨CentOS6.8安装Tomcat7]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E4%B8%A8CentOS6.8%E5%AE%89%E8%A3%85Tomcat7%2F</url>
    <content type="text"><![CDATA[安装环境123- 系统环境：CentOS6.8 64bit- Tomat版本：7.0.92- IP: 192.168.9.128 下载，上传，解压1[root@node01 ~]# tar -zxvf apache-tomcat-7.0.92.tar.gz -C /usr/local/tomcat/ 启动12345678[root@node01 local]# cd tomcat/apache-tomcat-7.0.92/bin/[root@node01 bin]# ./startup.sh Using CATALINA_BASE: /usr/local/tomcat/apache-tomcat-7.0.92Using CATALINA_HOME: /usr/local/tomcat/apache-tomcat-7.0.92Using CATALINA_TMPDIR: /usr/local/tomcat/apache-tomcat-7.0.92/tempUsing JRE_HOME: /usr/local/java/jdk1.8.0_201Using CLASSPATH: /usr/local/tomcat/apache-tomcat-7.0.92/bin/bootstrap.jar:/usr/local/tomcat/apache-tomcat-7.0.92/bin/tomcat-juli.jarTomcat started. 停止1234567[root@node01 bin]# ./shutdown.sh Using CATALINA_BASE: /usr/local/tomcat/apache-tomcat-7.0.92Using CATALINA_HOME: /usr/local/tomcat/apache-tomcat-7.0.92Using CATALINA_TMPDIR: /usr/local/tomcat/apache-tomcat-7.0.92/tempUsing JRE_HOME: /usr/local/java/jdk1.8.0_201Using CLASSPATH: /usr/local/tomcat/apache-tomcat-7.0.92/bin/bootstrap.jar:/usr/local/tomcat/apache-tomcat-7.0.92/bin/tomcat-juli.jar[root@node01 bin]# 设置防火墙12[root@node01 bin]# /sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT[root@node01 bin]# /etc/rc.d/init.d/iptables save 浏览器访问192.168.9.128:8080，打开tomcat页面，表示成功！ 参考资料1http://tomcat.apache.org/download-70.cgi]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux丨CentOS6.8安装MySQL5-6]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E4%B8%A8CentOS6.8%E5%AE%89%E8%A3%85MySQL5-6%2F</url>
    <content type="text"><![CDATA[安装环境123- 系统环境：CentOS6.8 64bit- MySQL版本：5.6.42- 安装方式：rpm 卸载自带的MySQL12345[root@node01 ~]# rpm -qa| grep mysqlmysql-libs-5.1.73-7.el6.x86_64[root@node01 ~]# rpm -e --nodeps mysql-libs-5.1.73-7.el6.x86_64[root@node01 ~]# rpm -qa | grep mysql[root@node01 ~]# 创建MySQL安装路径1[root@node01 ~]# mkdir /usr/local/mysql MySQL下载12MySQL Community Server 5.6.43Red Hat Enterprise Linux 6 / Oracle Linux 6 (x86, 64-bit) 上传RPM只需要把其中的3个PRM上传到/usr/local/mysql/下就行了，三者分别是： mysql-server：数据库服务器 mysql-client：客户端 mysql-devel：开发用到的库以及包含文件 123-rw-r--r--. 1 root root 57713020 2月 15 10:18 MySQL-server-5.6.43-1.el6.x86_64.rpm-rw-r--r--. 1 root root 19026428 2月 15 10:18 MySQL-client-5.6.43-1.el6.x86_64.rpm-rw-r--r--. 1 root root 3459304 2月 15 10:18 MySQL-devel-5.6.43-1.el6.x86_64.rpm 安装MySQL123[root@node01 mysql]# rpm -ivh MySQL-server-5.6.43-1.el6.x86_64.rpm --force --nodeps[root@node01 mysql]# rpm -ivh MySQL-client-5.6.43-1.el6.x86_64.rpm --force --nodeps[root@node01 mysql]# rpm -ivh MySQL-devel-5.6.43-1.el6.x86_64.rpm --force --nodeps 安装成功，可以看到一些信息：12345678910111213141516171819202122232425262728293031323334A RANDOM PASSWORD HAS BEEN SET FOR THE MySQL root USER !You will find that password in &apos;/root/.mysql_secret&apos;.You must change that password on your first connect,no other statement but &apos;SET PASSWORD&apos; will be accepted.See the manual for the semantics of the &apos;password expired&apos; flag.Also, the account for the anonymous user has been removed.In addition, you can run: /usr/bin/mysql_secure_installationwhich will also give you the option of removing the test database.This is strongly recommended for production servers.See the manual for more instructions.Please report any problems at http://bugs.mysql.com/The latest information about MySQL is available on the web at http://www.mysql.comSupport MySQL by buying support/licenses at http://shop.mysql.comNew default config file was created as /usr/my.cnf andwill be used by default by the server when you start it.You may edit this file to change server settingsWARNING: Default config file /etc/my.cnf exists on the systemThis file will be read by default by the MySQL serverIf you do not want to use this, either remove it, or use the--defaults-file argument to mysqld_safe when starting the server 大概说了2个事： mysql默认配置文件是/usr/my.cnf。 root用户给分配一个随机密码，到/root/.mysql_secret里面看。 12[root@node01 mysql]# cat /root/.mysql_secret# The random password set for the root user at Fri Feb 15 10:24:18 2019 (local time): PUMBwY3uVAbm0NNV 查看状态，启动123456[root@node01 mysql]# service mysql statusMySQL is not running [失败]--[root@node01 mysql]# service mysql restartMySQL server PID file could not be found! [失败]Starting MySQL. [确定] 登录，修改密码123456789101112131415161718192021[root@node01 mysql]# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.6.43Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; mysql&gt;mysql&gt; SET PASSWORD=PASSWORD(&apos;123456&apos;);Query OK, 0 rows affected (0.01 sec)mysql&gt; exitBye 用root和123456重新登录，如果可以登录，表示成功了！ 远程访问 修改表 1234567891011121314151617181920212223mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; update user set host=&apos;%&apos; where user = &apos;root&apos;;ERROR 1062 (23000): Duplicate entry &apos;%-root&apos; for key &apos;PRIMARY&apos;mysql&gt; mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; select host, user from user;+-----------+------+| host | user |+-----------+------+| % | root || 127.0.0.1 | root || ::1 | root || node01 | root |+-----------+------+4 rows in set (0.00 sec)mysql&gt; exit; 防火墙 123[root@node01 mysql]# iptables -I INPUT -s 0/0 -p tcp --dport 3306 -j ACCEPT[root@node01 mysql]# iptables -L -n|grep 3306ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:3306 测试远程连接，成功！ 开机自启1234-- 加入到系统服务[root@node01 mysql]# chkconfig --add mysql-- 自动启动[root@node01 mysql]# chkconfig mysql on 参考资料1234567https://segmentfault.com/a/1190000011454296https://www.cnblogs.com/weifeng1463/p/7941625.htmlhttps://kfcman.iteye.com/blog/2432058https://blog.csdn.net/dong_18383219470/article/details/57418629-- https://dev.mysql.com/downloads/mysql/http://mirrors.sohu.com/mysql/MySQL-5.6/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux丨CentOS6.8安装jdk1.8]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E4%B8%A8CentOS6.8%E5%AE%89%E8%A3%85jdk1.8%2F</url>
    <content type="text"><![CDATA[安装环境12- 系统环境：CentOS6.8 64bit- JDK版本：1.8.0_201 卸载OpenJDK1234567891011-- 查看[root@node01 ~]# rpm -qa | grep javatzdata-java-2016c-1.el6.noarchjava-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64-- 卸载[root@node01 ~]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64[root@node01 ~]# rpm -e --nodeps java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64-- 检验[root@node01 ~]# rpm -qa | grep javatzdata-java-2016c-1.el6.noarch 创建JDK文件夹，上传，解压12[root@node01 ~]# mkdir /usr/local/java[root@node01 ~]# tar -zxvf jdk-8u201-linux-x64.tar.gz -C /usr/local/java/ 配置环境变量1234567[root@node01 ~]# vim /etc/profile--# SET JDKJAVA_HOME=/usr/local/java/jdk1.8.0_201CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 重新加载配置文件1[root@node01 ~]# source /etc/profile 验证是否成功12345678[root@node01 ~]# java -versionjava version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)---java -versionjava javac 参考资料1https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo丨多台电脑使用hexo]]></title>
    <url>%2F2019%2F02%2F18%2FHexo%E4%B8%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8hexo%2F</url>
    <content type="text"><![CDATA[123456git initgit remote add origin https://github.com/wangjianuo/wangjianuo.github.iogit checkout -b sourcegit add .git commit -m "add source"git push origin source]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript丨selectpicker动态赋值不显示]]></title>
    <url>%2F2019%2F02%2F15%2FJavaScript%E4%B8%A8selectpicker%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC%E4%B8%8D%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[解决办法封装一个自定义方法功能：重新赋值，刷新，设置默认值。12345678910111213/** * bs select append 扩展 * @param &#123;*&#125; id 组件id * @param &#123;*&#125; opStr option * @param &#123;*&#125; selectedVal 默认值 */appendSelectExt: function (id, opStr, selectedVal) &#123; $(`#$&#123;id&#125;`).empty() $(`#$&#123;id&#125;`).append(opStr) $(`#$&#123;id&#125;`).selectpicker('refresh') $(`#$&#123;id&#125;`).selectpicker('val', selectedVal) //$(`#$&#123;id&#125;`).selectpicker('render')&#125; 调用方法12345678910let opStr = ''let selectedVal = ''for (let i = 0; i &lt; data.length; i++) &#123; const item = data[i] let selFlag = i === 0 ? 'selected' : '' if (i === 0) selectedVal = item.code opStr += `&lt;option value="$&#123;item.code&#125;" $&#123;selFlag&#125;&gt;$&#123;item.name&#125;&lt;/option&gt;`&#125;// bs selectpicker ext appendutils.appendSelectExt('nodeType', opStr, selectedVal) 参考资料123https://blog.csdn.net/u012083407/article/details/70305755https://www.cnblogs.com/mgzy/p/5755915.htmlhttps://www.cnblogs.com/daijun/p/7872663.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript丨未来元素datetimepicker失效]]></title>
    <url>%2F2019%2F02%2F15%2FJavaScript%E4%B8%A8%E6%9C%AA%E6%9D%A5%E5%85%83%E7%B4%A0datetimepicker%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[一、场景描述1、页面加载初始化datetimepicker组件 12345678910$(".form_datetime").datetimepicker(&#123; format: 'yyyy-mm-dd',//显示格式 todayHighlight: 1,//今天高亮 minView: "month",//设置只显示到月份 language: "zh-CN", startView: 2, forceParse: 0, showMeridian: 1, autoclose: 1//选择后自动关闭&#125;) 2、根据数据，动态创建多个datetimepicker组件 123456789101112131415161718192021/** * 动态创建Select元素 */dynCreateSelectDom: function (item) &#123; let ops = '' item.option.map(m =&gt; &#123; ops += `&lt;option value="$&#123;m.code&#125;" $&#123;m.code === item.value ? 'selected' : ''&#125;&gt;$&#123;m.name&#125;&lt;/option&gt;` &#125;) return ` &lt;div class="col-sm-6 com"&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt; $&#123;item.name&#125; &lt;/span&gt; &lt;select id="$&#123;item.id&#125;" onchange="handleDynChange(this)" class="form-control"&gt; $&#123;ops&#125; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; `&#125;, 3、发现datetimepicker组件失效，像一个普通的文本组件，无时间日期效果。 二、解决办法1、把初始化datetimepicker组件代码，封装为一个方法 123456789101112bindDatetimepicker: function () &#123; $(".form_datetime").datetimepicker(&#123; format: 'yyyy-mm-dd',//显示格式 todayHighlight: 1,//今天高亮 minView: "month",//设置只显示到月份 language: "zh-CN", startView: 2, forceParse: 0, showMeridian: 1, autoclose: 1//选择后自动关闭 &#125;)&#125;, 2、在动态创建多个datetimepicker组件后，再调用bindDatetimepicker方法。 三、参考资料1https://blog.csdn.net/sunnyzyq/article/details/77460355]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roadmap丨JavaWeb Dev in 2019]]></title>
    <url>%2F2018%2F03%2F27%2FRoadmap%E4%B8%A8JavaWeb%20Dev%20in%202019%2F</url>
    <content type="text"><![CDATA[JAVA WEB基础原理 Java JDK8 JVM 线程 并发 秒杀 负载 WEB框架 Spring Springboot SpringCloud MyBaits JPA DB MySQL 服务器 Tomcat Nginx 高阶 ELK MQ ZK Netty Dubbo 工具 Maven Git 容器 Docker K8S 大数据 Hadoop HDFS MapReduce Hbase Pig Hive Spark Storm Linux setup mysql nginx tomcat jdk elk docker 基础命令]]></content>
      <categories>
        <category>Roadmap</category>
      </categories>
      <tags>
        <tag>Roadmap</tag>
        <tag>JAVA WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roadmap丨Web Front-end Dev in 2019]]></title>
    <url>%2F2018%2F03%2F27%2FRoadmap%E4%B8%A8Web%20Front-end%20Dev%20in%202019%2F</url>
    <content type="text"><![CDATA[Web Front-end React react-router redux antd antd-mobile dva umi SSR Next.js After.js Webpack code spliting dll Gulp Web Front-end Containerization docker k8s Vue vue-cli vue-router vuex SSR Nuxt.js ES6/ES7 Web Front-end Security Web Front-end Optimization Nginx GZip Package Managers npm 开发一个NPM模块 yarn CSS Box Model Grid Flex Media Querie CSS Pre-processors Less Sass PostCSS CSS Frameworks BootStrap Basics of TypeScript Basics of JavaScript 闭包 作用域 变量提升 XHR和Ajax发起HTTP请求 第三方模块 moment.js Node.js express koa2 WeChat 小程序 公众号 H5开发 浏览器差异 可视化 ECharts D3.js Canvas SVG WebGL RESTful Git 参考资料1https://github.com/kamranahmedse/developer-roadmap]]></content>
      <categories>
        <category>Roadmap</category>
      </categories>
      <tags>
        <tag>Roadmap</tag>
        <tag>WEB FRONTEND</tag>
      </tags>
  </entry>
</search>
